/**************************************************************************
 * C S 429 system emulator
 *
 * instr_Decode.c - Decode stage of instruction processing pipeline.
 **************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <assert.h>
#include "instr.h"
#include "instr_pipeline.h"
#include "forward.h"
#include "machine.h"
#include "hw_elts.h"

#include "pthread.h"

#define SP_NUM 31
#define XZR_NUM 32

extern machine_t guest;
extern mem_status_t dmem_status;

extern pthread_barrier_t cycle_end;
extern pthread_barrier_t latch_end;

extern int64_t W_wval;

/*
 * Control signals for D, X, M, and W stages.
 * Generated by D stage logic.
 * D control signals are consumed locally.
 * Others must be buffered in pipeline registers.
 * STUDENT TO-DO:
 * Generate the correct control signals for this instruction's
 * future stages and write them to the corresponding struct.
 */
static comb_logic_t generate_DXMW_control(opcode_t op, d_ctl_sigs_t *D_sigs,
					  x_ctl_sigs_t *X_sigs,
					  m_ctl_sigs_t *M_sigs,
					  w_ctl_sigs_t *W_sigs)
{
	D_sigs->src2_sel = false;
	X_sigs->valb_sel = false;
	X_sigs->set_flags = false;
	M_sigs->dmem_read = false;
	M_sigs->dmem_write = false;
	W_sigs->dst_sel = false;
	W_sigs->wval_sel = false;
	W_sigs->w_enable = false;

	// D sig
	D_sigs->src2_sel = (op == OP_STUR);

	// X sigs
	X_sigs->valb_sel = (op == OP_ADDS_RR) || (op == OP_ANDS_RR) || (op == OP_SUBS_RR) || (op == OP_MVN) ||
			   (op == OP_EOR_RR) || (op == OP_CMN_RR) || (op == OP_ORR_RR) || (op == OP_CMP_RR) || (op == OP_TST_RR);

	X_sigs->set_flags = (op == OP_ADDS_RR) || (op == OP_SUBS_RR) || (op == OP_ANDS_RR) ||
			    (op == OP_CMN_RR) || (op == OP_CMP_RR) || (op == OP_TST_RR);

	// M sigs
	M_sigs->dmem_read = (op == OP_LDUR);
	M_sigs->dmem_write = (op == OP_STUR);

	// W sigs
	W_sigs->dst_sel = (op == OP_BL);
	W_sigs->wval_sel = (op == OP_LDUR);
	W_sigs->w_enable = !((op == OP_STUR) || (op == OP_ERROR) || (op == OP_B) ||
			     (op == OP_CMN_RR) || (op == OP_CMP_RR) || (op == OP_TST_RR) || (op == OP_B_COND) || (op == OP_RET) || (op == OP_NOP) || (op == OP_HLT));
}

/*
 * Logic for extracting the immediate value for M-, I-, and RI-format instructions.
 * STUDENT TO-DO:
 * Extract the immediate value and write it to *imm.
 */
static comb_logic_t extract_immval(uint32_t insnbits, opcode_t op,
				   int64_t *imm)
{
	// Student TODO
	switch (op)
	{
	case OP_LDUR:
		*imm = bitfield_s64(insnbits, 12, 9);
		break;
	case OP_STUR:
		*imm = bitfield_s64(insnbits, 12, 9);
		break;
	case OP_MOVK:
		*imm = bitfield_u32(insnbits, 5, 16);
		break;
	case OP_MOVZ:
		*imm = bitfield_u32(insnbits, 5, 16);
		break;
	case OP_ADRP:
	{
		uint32_t imm_lo = bitfield_u32(insnbits, 29, 2);
		uint32_t imm_hi = bitfield_u32(insnbits, 5, 19);
		int bits_left = 64 - (19 + 2);
		int64_t imm_join = ((int64_t)((imm_hi << 2) | imm_lo) << bits_left) >> bits_left;
		*imm = imm_join << 12;
		break;
	}
	case OP_ADD_RI:
		*imm = bitfield_u32(insnbits, 10, 12);
		break;
	case OP_SUB_RI:
		*imm = bitfield_u32(insnbits, 10, 12);
		break;
	case OP_UBFM:
		*imm = bitfield_u32(insnbits, 10, 12);
		break;
	case OP_LSR:
		*imm = bitfield_u32(insnbits, 16, 6);
		break;
	case OP_LSL:
		*imm = 64 - bitfield_u32(insnbits, 16, 6);
		break;
	case OP_ASR:
		*imm = bitfield_u32(insnbits, 10, 12);
		break;
	default:
		*imm = 0;
		break;
	}
}

/*
 * Logic for determining the ALU operation needed for this opcode.
 * STUDENT TO-DO:
 * Determine the ALU operation based on the given opcode
 * and write it to *ALU_op.
 */
static comb_logic_t decide_alu_op(opcode_t op, alu_op_t *ALU_op)
{
	// Student TODO
	switch (op)
	{
	case OP_NOP:
		*ALU_op = PASS_A_OP;
		break;
	case OP_LDUR:
		*ALU_op = PLUS_OP;
		break;
	case OP_STUR:
		*ALU_op = PLUS_OP;
		break;
	case OP_MOVK:
		*ALU_op = MOV_OP;
		break;
	case OP_MOVZ:
		*ALU_op = MOV_OP;
		break;
	case OP_ADRP:
		*ALU_op = PLUS_OP;
		break;
	case OP_ADD_RI:
		*ALU_op = PLUS_OP;
		break;
	case OP_ADDS_RR:
		*ALU_op = PLUS_OP;
		break;
	case OP_CMN_RR:
		*ALU_op = PLUS_OP;
		break;
	case OP_SUB_RI:
		*ALU_op = MINUS_OP;
		break;
	case OP_SUBS_RR:
		*ALU_op = MINUS_OP;
		break;
	case OP_CMP_RR:
		*ALU_op = MINUS_OP;
		break;
	case OP_MVN:
		*ALU_op = INV_OP;
		break;
	case OP_ORR_RR:
		*ALU_op = OR_OP;
		break;
	case OP_EOR_RR:
		*ALU_op = EOR_OP;
		break;
	case OP_ANDS_RR:
		*ALU_op = AND_OP;
		break;
	case OP_TST_RR:
		*ALU_op = AND_OP;
		break;
	case OP_LSL:
		*ALU_op = LSL_OP;
		break;
	case OP_LSR:
		*ALU_op = LSR_OP;
		break;
	case OP_UBFM:
		break;
	case OP_ASR:
		*ALU_op = ASR_OP;
		break;
	case OP_B:
		*ALU_op = PASS_A_OP;
		break;
	case OP_B_COND:
		*ALU_op = PASS_A_OP;
		break;
	case OP_BL:
		*ALU_op = PASS_A_OP;
		break;
	case OP_RET:
		*ALU_op = PASS_A_OP;
		break;
	case OP_HLT:
		*ALU_op = PASS_A_OP;
		break;
	default:
		*ALU_op = PASS_A_OP;
	}
}

/*
 * Utility functions for copying over control signals across a stage.
 * STUDENT TO-DO:
 * Copy the input signals from the input side of the pipeline
 * register to the output side of the register.
 */

comb_logic_t copy_m_ctl_sigs(m_ctl_sigs_t *dest, m_ctl_sigs_t *src)
{
	// Student TODO
	dest->dmem_read = src->dmem_read;
	dest->dmem_write = src->dmem_write;
}

comb_logic_t copy_w_ctl_sigs(w_ctl_sigs_t *dest, w_ctl_sigs_t *src)
{
	// Student TODO
	dest->dst_sel = src->dst_sel;
	dest->wval_sel = src->wval_sel;
	dest->w_enable = src->w_enable;
}

comb_logic_t extract_regs(uint32_t insnbits, opcode_t op, uint8_t *src1,
			  uint8_t *src2, uint8_t *dst)
{
	// Student TODO
	// all the formats with Rn (src1)
	if (op == OP_LDUR || op == OP_STUR || op == OP_ADD_RI || op == OP_ADDS_RR || op == OP_SUB_RI || op == OP_SUBS_RR ||
	    op == OP_CMP_RR || op == OP_MVN || op == OP_ORR_RR || op == OP_EOR_RR || op == OP_ANDS_RR ||
	    op == OP_TST_RR || op == OP_LSL || op == OP_LSR || op == OP_UBFM || op == OP_ASR ||
	    op == OP_RET || op == OP_CMN_RR)
	{
		*src1 = bitfield_u32(insnbits, 5, 5);
		if (*src1 == SP_NUM && !(op == OP_LDUR || op == OP_STUR || op == OP_ADD_RI || op == OP_SUB_RI))
		{
			*src1 = XZR_NUM;
		}
	}
	else
	{
		*src1 = XZR_NUM;
	}
	// all the formats with Rm (src2)
	if (op == OP_MVN || op == OP_ORR_RR || op == OP_EOR_RR || op == OP_ANDS_RR || op == OP_TST_RR || op == OP_ADDS_RR || op == OP_SUBS_RR || op == OP_CMN_RR || op == OP_CMP_RR)
	{
		*src2 = bitfield_u32(insnbits, 16, 5);
		if (*src2 == SP_NUM)
		{
			*src2 = XZR_NUM;
		}
	}
	else if (op == OP_NOP || op == OP_RET || op == OP_HLT)
	{
		*src2 = XZR_NUM;
	}
	else
	{
		*src2 = 0;
	}
	// all the formats with Rd (dst)
	if (op == OP_LDUR || op == OP_STUR || op == OP_MVN || op == OP_ORR_RR || op == OP_EOR_RR || op == OP_ANDS_RR ||
	    op == OP_TST_RR || op == OP_MOVK || op == OP_MOVZ || op == OP_ADRP || op == OP_ADD_RI || op == OP_SUB_RI ||
	    op == OP_CMP_RR || op == OP_ADDS_RR || op == OP_SUBS_RR || op == OP_CMP_RR || op == OP_CMN_RR || op == OP_LSL || op == OP_LSR ||
	    op == OP_UBFM || op == OP_ASR)
	{
		*dst = bitfield_u32(insnbits, 0, 5);
		if (op == OP_CMP_RR || op == OP_CMN_RR || op == OP_TST_RR)
		{
			*dst = XZR_NUM;
		}
	}
	else if (op == OP_BL)
	{
		*dst = 30;
	}
	else if (op == OP_RET)
	{
		*dst = XZR_NUM;
	}

	if (op == OP_ERROR)
	{
		*src1 = 0;
		*src2 = XZR_NUM;
		*dst = 0;
	}
	if (op == OP_MOVK)
	{
		*src1 = *dst;
	}
	if (op == OP_MOVZ)
	{
		*src1 = XZR_NUM;
	}
}

/*
 * Decode stage logic.
 * STUDENT TO-DO:
 * Implement the decode stage.
 *
 * Use `in` as the input pipeline register,
 * and update the `out` pipeline register as output.
 * Additionally, make sure the register file is updated
 * with W_out's output when you call it in this stage.
 *
 * You will also need the following helper functions:
 * generate_DXMW_control, regfile, extract_immval,
 * and decide_alu_op.
 */

// Helper to get the cond_t from the cond bits
static cond_t get_cond(uint32_t insnbits)
{
	cond_t cond = 0;
	switch (bitfield_u32(insnbits, 0, 4))
	{
	case 0b0000:
		cond = C_EQ;
		break;
	case 0b0001:
		cond = C_NE;
		break;
	case 0b0010:
		cond = C_CS;
		break;
	case 0b0011:
		cond = C_CC;
		break;
	case 0b0100:
		cond = C_MI;
		break;
	case 0b0101:
		cond = C_PL;
		break;
	case 0b0110:
		cond = C_VS;
		break;
	case 0b0111:
		cond = C_VC;
		break;
	case 0b1000:
		cond = C_HI;
		break;
	case 0b1001:
		cond = C_LS;
		break;
	case 0b1010:
		cond = C_GE;
		break;
	case 0b1011:
		cond = C_LT;
		break;
	case 0b1100:
		cond = C_GT;
		break;
	case 0b1101:
		cond = C_LE;
		break;
	case 0b1110:
		cond = C_AL;
		break;
	case 0b1111:
		cond = C_NV;
		break;
	default:
		break;
	}
	return cond;
}

comb_logic_t decode_instr(d_instr_impl_t *in, x_instr_impl_t *out)
{
	// Student TODO
	d_ctl_sigs_t D_sigs = {0};
	generate_DXMW_control(in->op, &D_sigs, &out->X_sigs, &out->M_sigs, &out->W_sigs);

	uint8_t src1, src2 = 0;

	extract_regs(in->insnbits, in->op, &src1, &src2, &out->dst);
	if (D_sigs.src2_sel)
	{
		src2 = out->dst;
	}
	regfile(src1, src2, W_out->dst, W_wval, W_out->W_sigs.w_enable, &out->val_a, &out->val_b);
	forward_reg(src1, src2, X_out->dst, W_in->dst, W_out->dst, M_in->val_ex, W_in->val_ex, W_in->val_mem, W_wval, W_wval,
	W_in->W_sigs.wval_sel, W_out->W_sigs.wval_sel, M_in->W_sigs.w_enable, W_in->W_sigs.w_enable, W_out->W_sigs.w_enable,
	&out->val_a, &out->val_b);
	extract_immval(in->insnbits, in->op, &out->val_imm);
	decide_alu_op(in->op, &out->ALU_op);
	if (in->op == OP_B_COND)
	{
		out->cond = get_cond(in->insnbits);
	}
	if (in->op == OP_MOVK || in->op == OP_MOVZ)
	{
		out->val_b = out->val_imm;
		out->val_hw = bitfield_u32(in->insnbits, 21, 2) << 4;

		if (in->op == OP_MOVZ)
		{
			out->val_a = 0;
		}
		else if (in->op == OP_MOVK)
		{
			out->val_a = out->val_a & ~(0xFFFFUL << out->val_hw);
		}
	}
	else
	{
		out->val_hw = 0;
	}
	if (in->op == OP_ADRP)
	{
		out->val_a = in->multipurpose_val.adrp_val;
	}

	out->op = in->op;
	out->print_op = in->print_op;
	out->status = in->status;
	out->seq_succ_PC = out->op == OP_ADRP ? in->multipurpose_val.adrp_val : in->multipurpose_val.seq_succ_PC;
}
